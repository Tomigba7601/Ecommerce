(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[283],{2283:function(e,r,t){"use strict";t.d(r,{Qr:function(){return L},cI:function(){return _e}});var n=t(7294),s=e=>"checkbox"===e.type,a=e=>e instanceof Date,u=e=>null==e;const c=e=>"object"===typeof e;var i=e=>!u(e)&&!Array.isArray(e)&&c(e)&&!a(e),l=e=>e.substring(0,e.search(/.\d/))||e,o=(e,r)=>[...e].some((e=>l(r)===e)),f=e=>e.filter(Boolean),d=e=>void 0===e,b=(e,r,t)=>{if(i(e)&&r){const n=f(r.split(/[,[\].]+?/)).reduce(((e,r)=>u(e)?e:e[r]),e);return d(n)||n===e?d(e[r])?t:e[r]:n}};const y="blur",g="change",m="onBlur",h="onChange",v="onSubmit",p="onTouched",O="all",w="max",_="min",j="maxLength",k="minLength",V="pattern",A="required",x="validate";var C=(e,r)=>{const t=Object.assign({},e);return delete t[r],t};const S=n.createContext(null);S.displayName="RHFContext";const F=()=>n.useContext(S);var D=(e,r,t,n,s=!0)=>e?new Proxy(r,{get:(e,r)=>{if(r in e)return t.current[r]!==O&&(t.current[r]=!s||O),n&&(n.current[r]=!0),e[r]}}):r,R=e=>i(e)&&!Object.keys(e).length,E=(e,r,t)=>{const n=C(e,"name");return R(n)||Object.keys(n).length>=Object.keys(r).length||Object.keys(n).find((e=>r[e]===(!t||O)))},N=e=>Array.isArray(e)?e:[e],B="undefined"!==typeof window&&"undefined"!==typeof window.HTMLElement&&"undefined"!==typeof document;const T=B?"Proxy"in window:"undefined"!==typeof Proxy;function M({name:e,rules:r,defaultValue:t,control:a,shouldUnregister:u}){const c=F(),{defaultValuesRef:l,register:f,fieldsRef:m,unregister:h,namesRef:v,subjectsRef:p,shouldUnmount:O,inFieldArrayActionRef:w}=a||c.control,_=b(m.current,e),[j,k]=n.useState(_&&_._f&&!d(_._f.value)?_._f.value:d(b(l.current,e))?t:b(l.current,e)),{onChange:V,onBlur:A,ref:x}=f(e,Object.assign(Object.assign({},r),{value:j})),C=function(e){const{control:r,name:t}=e||{},s=F(),{formStateRef:a,subjectsRef:u,readFormStateRef:c}=r||s.control,i=n.useRef(t);i.current=t;const[l,o]=n.useState(a.current),f=n.useRef({isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1});return n.useEffect((()=>{const e=u.current.state.subscribe({next:e=>(!i.current||!e.name||N(i.current).includes(e.name))&&E(e,f.current)&&o(Object.assign(Object.assign({},a.current),e))});return()=>e.unsubscribe()}),[]),D(T,l,c,f,!1)}({control:a||c.control,name:e});return n.useEffect((()=>{const r=b(m.current,e);r&&r._f&&(r._f._c=!0)})),n.useEffect((()=>{const r=p.current.control.subscribe({next:r=>(!r.name||e===r.name)&&k(b(r.values,e))});return()=>{r.unsubscribe();const t=O||u;if(o(v.current.array,e)?t&&!w.current:t)h(e);else{const r=b(m.current,e);r&&r._f&&(r._f.mount=!1)}}}),[e]),{field:{onChange:r=>{const t=(e=>i(e)&&e.target?s(e.target)?e.target.checked:e.target.value:e)(r);k(t),V({target:{value:t,name:e},type:g})},onBlur:()=>{A({target:{name:e},type:y})},name:e,value:j,ref:e=>e&&x(e)},formState:C,fieldState:{invalid:!!b(C.errors,e),isDirty:!!b(C.dirtyFields,e),isTouched:!!b(C.touchedFields,e),error:b(C.errors,e)}}}const L=e=>e.render(M(e));var I=(e,r,t,n,s)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:s||!0})}):{},U=e=>/^\w*$/.test(e),P=e=>f(e.replace(/["|']|\]/g,"").split(/\.|\[/));function q(e,r,t){let n=-1;const s=U(r)?[r]:P(r),a=s.length,u=a-1;for(;++n<a;){const r=s[n];let a=t;if(n!==u){const t=e[r];a=i(t)||Array.isArray(t)?t:isNaN(+s[n+1])?{}:[]}e[r]=a,e=e[r]}return e}const H=(e,r,t)=>{for(const n of t||Object.keys(e)){const t=b(e,n);if(t){const e=t._f,n=C(t,"_f");if(e&&r(e.name)){if(e.ref.focus&&d(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else i(n)&&H(n,r)}}},$=(e,r={})=>{for(const t in e.current){const n=e.current[t];if(n&&!u(r)){const e=n._f,s=C(n,"_f");q(r,t,e&&e.ref?e.ref.disabled||e.refs&&e.refs.every((e=>e.disabled))?void 0:e.value:Array.isArray(n)?[]:{}),s&&$({current:s},r[t])}}return r};var Q=e=>u(e)||!c(e);function z(e,r,t){if(Q(e)||Q(r)||a(e)||a(r))return e===r;if(!n.isValidElement(e)){const n=Object.keys(e),s=Object.keys(r);if(n.length!==s.length)return!1;for(const a of n){const n=e[a];if(!t||"ref"!==a){const e=r[a];if((i(n)||Array.isArray(n))&&(i(e)||Array.isArray(e))?!z(n,e,t):n!==e)return!1}}}return!0}function G(e,r){if(Q(e)||Q(r))return r;for(const n in r){const s=e[n],a=r[n];try{e[n]=i(s)&&i(a)||Array.isArray(s)&&Array.isArray(a)?G(s,a):a}catch(t){}}return e}function J(e,r,t,n,s){let a=-1;for(;++a<e.length;){for(const n in e[a])Array.isArray(e[a][n])?(!t[a]&&(t[a]={}),t[a][n]=[],J(e[a][n],b(r[a]||{},n,[]),t[a][n],t[a],n)):z(b(r[a]||{},n),e[a][n])?q(t[a]||{},n):t[a]=Object.assign(Object.assign({},t[a]),{[n]:!0});n&&!t.length&&delete n[s]}return t}var K=(e,r,t)=>G(J(e,r,t.slice(0,e.length)),J(r,e,t.slice(0,e.length)));var W=e=>"boolean"===typeof e;function X(e,r){const t=U(r)?[r]:P(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=d(e)?n++:e[r[n++]];return e}(e,t),s=t[t.length-1];let a;n&&delete n[s];for(let u=0;u<t.slice(0,-1).length;u++){let r,n=-1;const s=t.slice(0,-(u+1)),c=s.length-1;for(u>0&&(a=e);++n<s.length;){const t=s[n];r=r?r[t]:e[t],c===n&&(i(r)&&R(r)||Array.isArray(r)&&!r.filter((e=>i(e)&&!R(e)||W(e))).length)&&(a?delete a[t]:delete e[t]),a=r}}return e}var Y=e=>"file"===e.type,Z=e=>"select-multiple"===e.type,ee=e=>"radio"===e.type;const re={value:!1,isValid:!1},te={value:!0,isValid:!0};var ne=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:r,isValid:!!r.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!d(e[0].attributes.value)?d(e[0].value)||""===e[0].value?te:{value:e[0].value,isValid:!0}:te:re}return re},se=(e,{valueAsNumber:r,valueAsDate:t,setValueAs:n})=>d(e)?e:r?""===e?NaN:+e:t?new Date(e):n?n(e):e;const ae={isValid:!1,value:null};var ue=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.checked&&!r.disabled?{isValid:!0,value:r.value}:e),ae):ae;function ce(e){if(e&&e._f){const t=e._f.ref;if(t.disabled)return;return Y(t)?t.files:ee(t)?ue(e._f.refs).value:Z(t)?(r=t.options,[...r].filter((({selected:e})=>e)).map((({value:e})=>e))):s(t)?ne(e._f.refs).value:se(d(t.value)?e._f.ref.value:t.value,e._f)}var r}var ie=(e,r,t,n)=>{const s={};for(const a of e){const e=b(r,a);e&&q(s,a,e._f)}return{criteriaMode:t,names:[...e],fields:s,shouldUseNativeValidation:n}},le=e=>"function"===typeof e,oe=e=>"string"===typeof e,fe=e=>oe(e)||n.isValidElement(e),de=e=>e instanceof RegExp;function be(e,r,t="validate"){if(fe(e)||Array.isArray(e)&&e.every(fe)||W(e)&&!e)return{type:t,message:fe(e)?e:"",ref:r}}var ye=e=>i(e)&&!de(e)?e:{value:e,message:""},ge=async({_f:{ref:e,refs:r,required:t,maxLength:n,minLength:a,min:c,max:l,pattern:o,validate:f,name:d,value:b,valueAsNumber:y,mount:g}},m,h)=>{if(!g)return{};const v=r?r[0]:e,p=e=>{h&&v.reportValidity&&(v.setCustomValidity(W(e)?"":e||" "),v.reportValidity())},O={},C=ee(e),S=s(e),F=C||S,D=(y||Y(e))&&!e.value||""===b||Array.isArray(b)&&!b.length,E=I.bind(null,d,m,O),N=(r,t,n,s=j,a=k)=>{const u=r?t:n;O[d]=Object.assign({type:r?s:a,message:u,ref:e},E(r?s:a,u))};if(t&&(!F&&(D||u(b))||W(b)&&!b||S&&!ne(r).isValid||C&&!ue(r).isValid)){const{value:e,message:r}=fe(t)?{value:!!t,message:t}:ye(t);if(e&&(O[d]=Object.assign({type:A,message:r,ref:v},E(A,r)),!m))return p(r),O}if(!D&&(!u(c)||!u(l))){let r,t;const n=ye(l),s=ye(c);if(isNaN(b)){const a=e.valueAsDate||new Date(b);oe(n.value)&&(r=a>new Date(n.value)),oe(s.value)&&(t=a<new Date(s.value))}else{const a=e.valueAsNumber||parseFloat(b);u(n.value)||(r=a>n.value),u(s.value)||(t=a<s.value)}if((r||t)&&(N(!!r,n.message,s.message,w,_),!m))return p(O[d].message),O}if((n||a)&&!D&&oe(b)){const e=ye(n),r=ye(a),t=!u(e.value)&&b.length>e.value,s=!u(r.value)&&b.length<r.value;if((t||s)&&(N(t,e.message,r.message),!m))return p(O[d].message),O}if(o&&!D&&oe(b)){const{value:r,message:t}=ye(o);if(de(r)&&!b.match(r)&&(O[d]=Object.assign({type:V,message:t,ref:e},E(V,t)),!m))return p(t),O}if(f)if(le(f)){const e=be(await f(b),v);if(e&&(O[d]=Object.assign(Object.assign({},e),E(x,e.message)),!m))return p(e.message),O}else if(i(f)){let e={};for(const r in f){if(!R(e)&&!m)break;const t=be(await f[r](b),v,r);t&&(e=Object.assign(Object.assign({},t),E(r,t.message)),p(t.message),m&&(O[d]=e))}if(!R(e)&&(O[d]=Object.assign({ref:v},e),!m))return O}return p(!0),O},me=e=>({isOnSubmit:!e||e===v,isOnBlur:e===m,isOnChange:e===h,isOnAll:e===O,isOnTouch:e===p}),he=e=>e instanceof HTMLElement;class ve{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class pe{constructor(e,r){this.observer=e,this.closed=!1,r.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class Oe{constructor(){this.observers=[]}next(e){for(const r of this.observers)r.next(e)}subscribe(e){const r=new ve,t=new pe(e,r);return this.observers.push(t),r}unsubscribe(){this.observers=[]}}const we="undefined"===typeof window;function _e({mode:e=v,reValidateMode:r=h,resolver:t,context:c,defaultValues:g={},shouldFocusError:m=!0,shouldUseNativeValidation:p,shouldUnregister:w,criteriaMode:_}={}){const[j,k]=n.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}}),V=n.useRef({isDirty:!T,dirtyFields:!T,touchedFields:!T,isValidating:!T,isValid:!T,errors:!T}),A=n.useRef(t),x=n.useRef(j),S=n.useRef({}),F=n.useRef(g),M=n.useRef({}),L=n.useRef(c),I=n.useRef(!1),U=n.useRef(!1),P=n.useRef({watch:new Oe,control:new Oe,array:new Oe,state:new Oe}),G=n.useRef({mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1}),J=me(e),W=_===O;A.current=t,L.current=c;const re=e=>G.current.watchAll||G.current.watch.has(e)||G.current.watch.has((e.match(/\w+/)||[])[0]),te=n.useCallback((async(e,r,n,s,a,u)=>{const c=b(x.current.errors,r),i=!!V.current.isValid&&(t?a:await be(S.current,!0));if(n?q(x.current.errors,r,n):X(x.current.errors,r),(u||(n?!z(c,n,!0):c)||!R(s)||x.current.isValid!==i)&&!e){const e=Object.assign(Object.assign({},s),{isValid:!!i,errors:x.current.errors,name:r});x.current=Object.assign(Object.assign({},x.current),e),P.current.state.next(u?{name:r}:e)}P.current.state.next({isValidating:!1})}),[]),ne=n.useCallback(((e,r,t={},n,a)=>{a&&Ce(e);const c=b(S.current,e);if(c){const a=c._f;if(a){const c=B&&he(a.ref)&&u(r)?"":r;if(a.value=se(r,a),ee(a.ref)&&!a._c?(a.refs||[]).forEach((e=>e.checked=e.value===c)):!Y(a.ref)||oe(c)||a._c?Z(a.ref)?[...a.ref.options].forEach((e=>e.selected=c.includes(e.value))):s(a.ref)&&a.refs&&!a._c?a.refs.length>1?a.refs.forEach((e=>e.checked=Array.isArray(c)?!!c.find((r=>r===e.value)):c===e.value)):a.refs[0].checked=!!c:a.ref.value=c:a.ref.files=c,n&&a._c){const t=$(S);q(t,e,r),P.current.control.next({values:Object.assign(Object.assign({},F.current),t),name:e})}(t.shouldDirty||t.shouldTouch)&&ue(e,c,t.shouldTouch),t.shouldValidate&&ye(e)}else c._f={ref:{name:e,value:r},value:r}}}),[]),ae=n.useCallback(((e,r)=>{const t=$(S);return e&&r&&q(t,e,r),!z(t,F.current)}),[]),ue=n.useCallback(((e,r,t,n=!0)=>{const s={name:e};let a=!1;if(V.current.isDirty){const e=x.current.isDirty;x.current.isDirty=ae(),s.isDirty=x.current.isDirty,a=e!==s.isDirty}if(V.current.dirtyFields&&!t){const t=b(x.current.dirtyFields,e);!z(b(F.current,e),r)?q(x.current.dirtyFields,e,!0):X(x.current.dirtyFields,e),s.dirtyFields=x.current.dirtyFields,a=a||t!==b(x.current.dirtyFields,e)}const u=b(x.current.touchedFields,e);return t&&!u&&(q(x.current.touchedFields,e,t),s.touchedFields=x.current.touchedFields,a=a||V.current.touchedFields&&u!==t),a&&n&&P.current.state.next(s),a?s:{}}),[]),fe=n.useCallback((async(e,r)=>{const t=(await ge(b(S.current,e),W,p))[e];return await te(r,e,t),d(t)}),[W]),de=n.useCallback((async e=>{const{errors:r}=await A.current($(S),L.current,ie(G.current.mount,S.current,_,p));if(e)for(const t of e){const e=b(r,t);e?q(x.current.errors,t,e):X(x.current.errors,t)}else x.current.errors=r;return r}),[_,p]),be=async(e,r,t={valid:!0})=>{for(const n in e){const s=e[n];if(s){const e=s._f,n=C(s,"_f");if(e){const n=await ge(s,W,p);if(r){if(n[e.name]){t.valid=!1;break}}else n[e.name]?q(x.current.errors,e.name,n[e.name]):X(x.current.errors,e.name)}n&&await be(n,r,t)}}return t.valid},ye=n.useCallback((async(e,r={})=>{const n=N(e);let s;if(P.current.state.next({isValidating:!0}),t){const r=await de(d(e)?e:n);s=e?n.every((e=>!b(r,e))):R(r)}else e?s=(await Promise.all(n.filter((e=>b(S.current,e,{})._f)).map((async e=>await fe(e,!0))))).every(Boolean):(await be(S.current),s=R(x.current.errors));return P.current.state.next(Object.assign(Object.assign({},oe(e)?{name:e}:{}),{errors:x.current.errors,isValidating:!1})),r.shouldFocus&&!s&&H(S.current,(e=>b(x.current.errors,e)),e?n:G.current.mount),V.current.isValid&&pe(),s}),[de,fe]),ve=(e,r)=>{const t=b(S.current,e);if(t){const n=d(t._f.value),s=n?d(b(M.current,e))?b(F.current,e):b(M.current,e):t._f.value;d(s)?n&&(t._f.value=ce(t)):r&&r.defaultChecked?t._f.value=ce(t):ne(e,s)}U.current&&V.current.isValid&&pe()},pe=n.useCallback((async(e={})=>{const r=t?R((await A.current(Object.assign(Object.assign({},$(S)),e),L.current,ie(G.current.mount,S.current,_,p))).errors):await be(S.current,!0);r!==x.current.isValid&&P.current.state.next({isValid:r})}),[_,p]),_e=n.useCallback(((e,r,t)=>Object.entries(r).forEach((([r,n])=>{const s=`${e}.${r}`,u=b(S.current,s);!G.current.array.has(e)&&Q(n)&&(!u||u._f)||a(n)?ne(s,n,t,!0,!u):_e(s,n,t)}))),[ye]),je=n.useCallback((async({type:e,target:n,target:{value:a,name:u,type:c}})=>{let i,o;const f=b(S.current,u);if(f){let m=c?ce(f):void 0;m=d(m)?a:m;const h=e===y,{isOnBlur:v,isOnChange:O}=me(r),w=(g=f._f,!(f._f.mount&&g&&(g.required||g.min||g.max||g.maxLength||g.minLength||g.pattern||g.validate))&&!t&&!b(x.current.errors,u)||(({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:s,isReValidateOnChange:a,isBlurEvent:u,isSubmitted:c,isOnAll:i})=>!i&&(!c&&t?!(n||u):(c?s:e)?!u:!(c?a:r)||u))(Object.assign({isBlurEvent:h,isTouched:!!b(x.current.touchedFields,u),isSubmitted:x.current.isSubmitted,isReValidateOnBlur:v,isReValidateOnChange:O},J))),j=!h&&re(u);d(m)||(f._f.value=m);const k=ue(u,f._f.value,h,!1),V=!R(k)||j;if(w)return!h&&P.current.watch.next({name:u,type:e,values:ke()}),V&&P.current.state.next(j?{name:u}:Object.assign(Object.assign({},k),{name:u}));if(P.current.state.next({isValidating:!0}),t){const{errors:e}=await A.current($(S),L.current,ie([u],S.current,_,p));if(i=b(e,u),s(n)&&!i){const r=l(u),t=b(e,r,{});t.type&&t.message&&(i=t),(t||b(x.current.errors,r))&&(u=r)}o=R(e)}else i=(await ge(f,W,p))[u];!h&&P.current.watch.next({name:u,type:e,values:ke()}),te(!1,u,i,k,o,j)}var g}),[]),ke=e=>{const r=Object.assign(Object.assign({},F.current),$(S));return d(e)?r:oe(e)?b(r,e):e.map((e=>b(r,e)))},Ve=n.useCallback(((e,r,t,n)=>{const s=Array.isArray(e),a=n||U.current?Object.assign(Object.assign({},F.current),n||$(S)):d(r)?F.current:s?r:{[e]:r};if(d(e))return t&&(G.current.watchAll=!0),a;const u=[];for(const c of N(e))t&&G.current.watch.add(c),u.push(b(a,c));return s?u:u[0]}),[]),Ae=(e,r={})=>{for(const t of e?N(e):G.current.mount)G.current.mount.delete(t),G.current.array.delete(t),b(S.current,t)&&(!r.keepError&&X(x.current.errors,t),!r.keepValue&&X(S.current,t),!r.keepDirty&&X(x.current.dirtyFields,t),!r.keepTouched&&X(x.current.touchedFields,t),!w&&!r.keepDefaultValue&&X(F.current,t));P.current.watch.next({values:ke()}),P.current.state.next(Object.assign(Object.assign({},x.current),r.keepDirty?{isDirty:ae()}:{})),!r.keepIsValid&&pe()},xe=(e,r,t)=>{Ce(e,t);let n=b(S.current,e);const a=(e=>ee(e)||s(e))(r);r===n._f.ref||a&&f(n._f.refs||[]).find((e=>e===r))||(n={_f:a?Object.assign(Object.assign({},n._f),{refs:[...f(n._f.refs||[]).filter((e=>he(e)&&document.contains(e))),r],ref:{type:r.type,name:e}}):Object.assign(Object.assign({},n._f),{ref:r})},q(S.current,e,n),ve(e,r))},Ce=n.useCallback(((e,r={})=>{const t=b(S.current,e);return q(S.current,e,{_f:Object.assign(Object.assign(Object.assign({},t&&t._f?t._f:{ref:{name:e}}),{name:e,mount:!0}),r)}),G.current.mount.add(e),!t&&ve(e),we?{name:e}:{name:e,onChange:je,onBlur:je,ref:t=>{if(t)xe(e,t,r);else{const t=b(S.current,e,{}),n=w||r.shouldUnregister;t._f&&(t._f.mount=!1,d(t._f.value)&&(t._f.value=t._f.ref.value)),n&&(!o(G.current.array,e)||!I.current)&&G.current.unMount.add(e)}}}}),[]),Se=n.useCallback(((e,r)=>async n=>{n&&(n.preventDefault&&n.preventDefault(),n.persist&&n.persist());let s=!0,a=$(S);P.current.state.next({isSubmitting:!0});try{if(t){const{errors:e,values:r}=await A.current(a,L.current,ie(G.current.mount,S.current,_,p));x.current.errors=e,a=r}else await be(S.current);R(x.current.errors)&&Object.keys(x.current.errors).every((e=>b(a,e)))?(P.current.state.next({errors:{},isSubmitting:!0}),await e(a,n)):(r&&await r(x.current.errors,n),m&&H(S.current,(e=>b(x.current.errors,e)),G.current.mount))}catch(u){throw s=!1,u}finally{x.current.isSubmitted=!0,P.current.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:R(x.current.errors)&&s,submitCount:x.current.submitCount+1,errors:x.current.errors})}}),[m,W,_,p]),Fe=(e,r="")=>{for(const t in e){const n=e[t],s=r+(r?".":"")+t,a=b(S.current,s);a&&a._f||(i(n)||Array.isArray(n)?Fe(n,s):a||Ce(s,{value:n}))}};return n.useEffect((()=>{const e=P.current.state.subscribe({next(e){E(e,V.current,!0)&&(x.current=Object.assign(Object.assign({},x.current),e),k(x.current))}}),r=P.current.array.subscribe({next(e){if(e.values&&e.name&&V.current.isValid){const r=$(S);q(r,e.name,e.values),pe(r)}}});return()=>{e.unsubscribe(),r.unsubscribe()}}),[]),n.useEffect((()=>{const e=[],r=e=>!he(e)||!document.contains(e);U.current||(U.current=!0,V.current.isValid&&pe(),!w&&Fe(F.current));for(const t of G.current.unMount){const n=b(S.current,t);n&&(n._f.refs?n._f.refs.every(r):r(n._f.ref))&&e.push(t)}e.length&&Ae(e),G.current.unMount=new Set})),{control:n.useMemo((()=>({register:Ce,inFieldArrayActionRef:I,getIsDirty:ae,subjectsRef:P,watchInternal:Ve,fieldsRef:S,updateIsValid:pe,namesRef:G,readFormStateRef:V,formStateRef:x,defaultValuesRef:F,fieldArrayDefaultValuesRef:M,setValues:_e,unregister:Ae,shouldUnmount:w})),[]),formState:D(T,j,V),trigger:ye,register:Ce,handleSubmit:Se,watch:n.useCallback(((e,r)=>le(e)?P.current.watch.subscribe({next:t=>e(Ve(void 0,r),t)}):Ve(e,r,!0)),[]),setValue:n.useCallback(((e,r,t={})=>{const n=b(S.current,e),s=G.current.array.has(e);s&&(P.current.array.next({values:r,name:e,isReset:!0}),(V.current.isDirty||V.current.dirtyFields)&&t.shouldDirty&&(q(x.current.dirtyFields,e,K(r,b(F.current,e,[]),b(x.current.dirtyFields,e,[]))),P.current.state.next({name:e,dirtyFields:x.current.dirtyFields,isDirty:ae(e,r)})),!r.length&&q(S.current,e,[])&&q(M.current,e,[])),(n&&!n._f||s)&&!u(r)?_e(e,r,s?{}:t):ne(e,r,t,!0,!n),re(e)&&P.current.state.next({}),P.current.watch.next({name:e,values:ke()})}),[_e]),getValues:n.useCallback(ke,[]),reset:n.useCallback(((e,r={})=>{const t=e||F.current;if(B&&!r.keepValues)for(const s of G.current.mount){const e=b(S.current,s);if(e&&e._f){const r=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;try{he(r)&&r.closest("form").reset();break}catch(n){}}}!r.keepDefaultValues&&(F.current=Object.assign({},t)),r.keepValues||(S.current={},P.current.control.next({values:r.keepDefaultValues?F.current:Object.assign({},t)}),P.current.watch.next({values:Object.assign({},t)}),P.current.array.next({values:Object.assign({},t),isReset:!0})),G.current={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1},P.current.state.next({submitCount:r.keepSubmitCount?x.current.submitCount:0,isDirty:r.keepDirty?x.current.isDirty:!!r.keepDefaultValues&&z(e,F.current),isSubmitted:!!r.keepIsSubmitted&&x.current.isSubmitted,dirtyFields:r.keepDirty?x.current.dirtyFields:{},touchedFields:r.keepTouched?x.current.touchedFields:{},errors:r.keepErrors?x.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),U.current=!!r.keepIsValid}),[]),clearErrors:n.useCallback((e=>{e?N(e).forEach((e=>X(x.current.errors,e))):x.current.errors={},P.current.state.next({errors:x.current.errors})}),[]),unregister:n.useCallback(Ae,[]),setError:n.useCallback(((e,r,t)=>{const n=((b(S.current,e)||{_f:{}})._f||{}).ref;q(x.current.errors,e,Object.assign(Object.assign({},r),{ref:n})),P.current.state.next({name:e,errors:x.current.errors,isValid:!1}),t&&t.shouldFocus&&n&&n.focus&&n.focus()}),[]),setFocus:n.useCallback((e=>b(S.current,e)._f.ref.focus()),[])}}}}]);